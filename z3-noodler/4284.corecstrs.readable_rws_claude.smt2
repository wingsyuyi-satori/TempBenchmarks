(set-info :smt-lib-version 2.6)
(set-logic QF_SLIA)
(set-info :source |
Generated by: LLM-based constraint generator
Application: CSV/TSV field validation and processing
Target solver: CVC4, Z3, Z3str3, Z3-Noodler
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)

; Input data records with different delimiters
(declare-const tsv_record String)
(declare-const pipe_record String)
(declare-const semicolon_record String)

; TSV processing - tab-separated values
(declare-const tab_field_count Int)
(assert (= tab_field_count (str.num_splits tsv_record " ")))
(assert (= tab_field_count 4))

; ; Extract TSV fields
(declare-const name_field String)
(declare-const age_field String)
(declare-const email_field String)
(declare-const status_field String)
(assert (= name_field (str.split_at tsv_record " " 0)))
(assert (= age_field (str.split_at tsv_record " " 1)))
(assert (= email_field (str.split_at tsv_record " " 2)))
(assert (= status_field (str.split_at tsv_record " " 3)))

; Pipe-delimited record processing
(declare-const pipe_count Int)
(assert (= pipe_count (str.num_splits pipe_record "|")))
(assert (>= pipe_count 5))

; ; Extract key pipe fields
(declare-const product_id String)
(declare-const category String)
(declare-const price_field String)
(assert (= product_id (str.split_at pipe_record "|" 0)))
(assert (= category (str.split_at pipe_record "|" 1)))
(assert (= price_field (str.split_at pipe_record "|" 2)))

; Get remaining pipe fields for bulk processing
(declare-const pipe_tail String)
(assert (= pipe_tail (str.split_rest pipe_record "|" 3)))

; Semicolon-delimited European CSV format
(declare-const euro_field_count Int)
(assert (= euro_field_count (str.num_splits semicolon_record ";")))
(assert (and (>= euro_field_count 3) (<= euro_field_count 6)))

; ; Extract European format fields
(declare-const customer_name String)
(declare-const amount_euro String)
(declare-const currency_code String)
(assert (= customer_name (str.split_at semicolon_record ";" 0)))
(assert (= amount_euro (str.split_at semicolon_record ";" 1)))
(assert (= currency_code (str.split_at semicolon_record ";" 2)))

; Field validation constraints
; Name field cannot be empty
(assert (> (str.len name_field) 0))
(assert (> (str.len customer_name) 0))

; Product ID must be non-empty and alphanumeric-like
(assert (> (str.len product_id) 0))
(assert (not (str.contains product_id " ")))

; Email field must contain @ symbol
(assert (str.contains email_field "@"))

; Age field should be numeric-like (no letters)
(assert (not (str.contains age_field "a")))
(assert (not (str.contains age_field "z")))

; Price field should not be empty
(assert (> (str.len price_field) 0))

; Currency code should be exactly 3 characters
(assert (= (str.len currency_code) 3))

; Empty field handling - some fields can be empty
(declare-const optional_field String)
(assert (= optional_field (str.split_at pipe_record "|" 4)))
; Optional field can be empty
(assert (>= (str.len optional_field) 0))

; Escape sequence validation - no unescaped quotes in TSV
(assert (not (str.contains name_field """)))
(assert (not (str.contains email_field """)))

; ; Cross-format consistency check
; If records represent same entity, some fields should match
(declare-const entity_match Bool)
(assert (= entity_match (= name_field customer_name)))

; Field count relationships
(assert (>= tab_field_count 3))
(assert (<= pipe_count 8))

(check-sat)
(get-model)
