(set-info :smt-lib-version 2.6)
(set-logic QF_SLIA)
(set-info :source |
Generated by: LLM-based constraint generator
Application: CSV/TSV field validation with multiple delimiters
Target solver: CVC4, Z3, Z3str3, Z3-Noodler
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)

; Multiple CSV/TSV records with different delimiters
(declare-const tsv_record String)
(declare-const csv_record String)
(declare-const pipe_record String)
(declare-const semicolon_record String)

; TSV processing with tab delimiter
(declare-const tsv_name String)
(declare-const tsv_age String)
(declare-const tsv_email String)
(assert (= tsv_name (str.split_at tsv_record "\t" 0)))
(assert (= tsv_age (str.split_at tsv_record "\t" 1)))
(assert (= tsv_email (str.split_at tsv_record "\t" 2)))

; TSV must have exactly 3 fields
(assert (= (str.num_splits tsv_record "\t") 3))

; CSV processing with comma delimiter
(declare-const csv_product String)
(declare-const csv_price String)
(declare-const csv_category String)
(declare-const csv_description String)
(assert (= csv_product (str.split_at csv_record "," 0)))
(assert (= csv_price (str.split_at csv_record "," 1)))
(assert (= csv_category (str.split_at csv_record "," 2)))
(assert (= csv_description (str.split_at csv_record "," 3)))

; CSV must have at least 4 fields
(assert (>= (str.num_splits csv_record ",") 4))

; Pipe-delimited record processing
(declare-const pipe_field_count Int)
(assert (= pipe_field_count (str.num_splits pipe_record "|")))
(assert (and (>= pipe_field_count 2) (<= pipe_field_count 6)))

; ; Extract first and last fields from pipe record
(declare-const pipe_first String)
(declare-const pipe_last String)
(assert (= pipe_first (str.split_at pipe_record "|" 0)))
(assert (= pipe_last (str.split_at pipe_record "|" (- pipe_field_count 1))))

; Semicolon-delimited record with empty field handling
(declare-const semi_field1 String)
(declare-const semi_field2 String)
(declare-const semi_field3 String)
(assert (= semi_field1 (str.split_at semicolon_record ";" 0)))
(assert (= semi_field2 (str.split_at semicolon_record ";" 1)))
(assert (= semi_field3 (str.split_at semicolon_record ";" 2)))

; Allow empty fields in semicolon record but not all empty
(assert (or (> (str.len semi_field1) 0) 
 (> (str.len semi_field2) 0) 
 (> (str.len semi_field3) 0)))

; Cross-format validation: name fields should not contain delimiters
(assert (not (str.contains tsv_name ",")))
(assert (not (str.contains tsv_name ";")))
(assert (not (str.contains tsv_name "|")))

; Price field validation - no tabs or pipes allowed
(assert (not (str.contains csv_price "\t")))
(assert (not (str.contains csv_price "|")))

; Email validation - must contain @ and no control characters
(assert (str.contains tsv_email "@"))
(assert (not (str.contains tsv_email "\t")))
(assert (not (str.contains tsv_email "\n")))

; Product name cannot be empty and must not exceed 50 characters
(assert (> (str.len csv_product) 0))
(assert (<= (str.len csv_product) 50))

; Ensure records have minimum content length
(assert (> (str.len tsv_record) 10))
(assert (> (str.len csv_record) 15))
(assert (> (str.len pipe_record) 5))

; Get remaining CSV fields for additional processing
(declare-const csv_extras String)
(assert (= csv_extras (str.split_rest csv_record "," 4)))

(check-sat)
(get-model)
