(set-info :smt-lib-version 2.6)
(set-logic QF_SLIA)
(set-info :source |
Generated by: LLM-based constraint generator
Application: Multi-delimiter CSV/TSV validation scenario
Target solver: CVC4, Z3, Z3str3, Z3-Noodler
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)

; Input data lines with different delimiters
(declare-const tsv_record String)
(declare-const pipe_record String)
(declare-const semicolon_record String)

; TSV processing - tab-separated values
(declare-const tab_field_count Int)
(assert (= tab_field_count (str.num_splits tsv_record "\t")))
(assert (= tab_field_count 4))

; ; Extract TSV fields
(declare-const tsv_name String)
(declare-const tsv_age String)
(declare-const tsv_email String)
(declare-const tsv_notes String)
(assert (= tsv_name (str.split_at tsv_record "\t" 0)))
(assert (= tsv_age (str.split_at tsv_record "\t" 1)))
(assert (= tsv_email (str.split_at tsv_record "\t" 2)))
(assert (= tsv_notes (str.split_at tsv_record "\t" 3)))

; Name field validation - no empty names
(assert (> (str.len tsv_name) 0))
(assert (not (str.contains tsv_name "\t")))

; Age field validation - numeric constraints
(assert (> (str.len tsv_age) 0))
(assert (<= (str.len tsv_age) 3))

; Email validation - must contain @ symbol
(assert (str.contains tsv_email "@"))
(assert (> (str.len tsv_email) 5))

; Pipe-delimited record processing
(declare-const pipe_segments Int)
(assert (= pipe_segments (str.num_splits pipe_record "|")))
(assert (>= pipe_segments 5))

; ; Extract key pipe fields
(declare-const product_id String)
(declare-const product_price String)
(declare-const product_desc String)
(assert (= product_id (str.split_at pipe_record "|" 0)))
(assert (= product_price (str.split_at pipe_record "|" 1)))
(assert (= product_desc (str.split_at pipe_record "|" 2)))

; Product ID must be non-empty and alphanumeric-like
(assert (> (str.len product_id) 0))
(assert (not (str.contains product_id "|")))
(assert (not (str.contains product_id " ")))

; Price field cannot be empty
(assert (> (str.len product_price) 0))

; Get remaining product attributes
(declare-const remaining_attrs String)
(assert (= remaining_attrs (str.split_rest pipe_record "|" 3)))
(assert (> (str.len remaining_attrs) 0))

; Semicolon-delimited processing
(declare-const semi_field_total Int)
(assert (= semi_field_total (str.num_splits semicolon_record ";")))
(assert (and (>= semi_field_total 3) (<= semi_field_total 6)))

; ; Extract semicolon fields with empty field handling
(declare-const config_key String)
(declare-const config_value String)
(declare-const config_type String)
(assert (= config_key (str.split_at semicolon_record ";" 0)))
(assert (= config_value (str.split_at semicolon_record ";" 1)))
(assert (= config_type (str.split_at semicolon_record ";" 2)))

; Configuration key must exist
(assert (> (str.len config_key) 0))

; Allow empty config values but not empty types
(assert (>= (str.len config_value) 0))
(assert (> (str.len config_type) 0))

; Cross-delimiter validation - no delimiter bleeding
(assert (not (str.contains tsv_record "|")))
(assert (not (str.contains pipe_record ";")))
(assert (not (str.contains semicolon_record "\t")))

; Escape sequence handling - no unescaped quotes in fields
(assert (not (str.contains product_desc """")))
(assert (not (str.contains tsv_notes """")))
(assert (not (str.contains config_value """")))

; Field length consistency checks
(assert (< (str.len tsv_name) 50))
(assert (< (str.len product_desc) 200))
(assert (< (str.len config_key) 30))

(check-sat)
(exit)
(get-model)
