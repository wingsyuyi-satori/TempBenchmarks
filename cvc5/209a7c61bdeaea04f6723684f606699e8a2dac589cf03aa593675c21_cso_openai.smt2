(set-info :smt-lib-version 2.6)
(set-logic QF_SLIA)
(set-info :source |
Generated by: Wei-Cheng Wu
Generated on: 2020-02-24
Generator: PyExZ3
Application: Concolic execution of Python code
Target solver: CVC4, Z3, Z3str3, Z3-Trau
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)

(declare-fun s () String)
(declare-fun p () String)

(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (not (not (not (= (ite (> (str.len s) 10) 1 0) 0)))) (not (= (ite (= (str.len p) 7) 1 0) 0))) (not (= (ite (= (- (+ (- (+ (- (+ (- (- (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) 1 0) 0))) (not (= (ite (> (str.len s) 9) 1 0) 0))) (not (= (ite (= (str.len p) 7) 1 0) 0))) (not (= (ite (= (- (+ (- (+ (- (- (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) 1 0) 0))) (not (= (ite (> (str.len s) 8) 1 0) 0))) (not (= (ite (= (str.len p) 7) 1 0) 0))) (not (= (ite (= (- (+ (- (- (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) 1 0) 0))) (not (= (ite (> (str.len s) 7) 1 0) 0))) (not (= (ite (= (str.len p) 7) 1 0) 0))) (not (= (ite (= (- (- (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 1) 1) 0) 1 0) 0))) (not (= (ite (> (str.len s) 6) 1 0) 0))) (not (not (= (ite (= (str.len p) 6) 1 0) 0)))) (not (not (= (ite (= (- (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 5) 1 0) 0))) (not (not (= (ite (= (str.len p) 5) 1 0) 0)))) (not (not (= (ite (= (- (- (- (- (- (str.len p) 1) 1) 1) 1) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 4) 1 0) 0))) (not (not (= (ite (= (str.len p) 4) 1 0) 0)))) (not (not (= (ite (= (- (- (- (- (str.len p) 1) 1) 1) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 3) 1 0) 0))) (not (not (= (ite (= (str.len p) 3) 1 0) 0)))) (not (not (= (ite (= (- (- (- (str.len p) 1) 1) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 2) 1 0) 0))) (not (not (= (ite (= (str.len p) 2) 1 0) 0)))) (not (not (= (ite (= (- (- (str.len p) 1) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 1) 1 0) 0))) (not (not (= (ite (= (str.len p) 1) 1 0) 0)))) (not (not (= (ite (= (- (str.len p) 1) 0) 1 0) 0)))) (not (= (ite (> (str.len s) 0) 1 0) 0))) (not (not (= (ite (= (str.len p) 0) 1 0) 0)))) (not (not (= (ite (= (str.len s) 0) 1 0) 0)))))

; --- LLM Generated Split Constraints ---
; We split s by delimiter "-"
(declare-const s_parts_count Int)
(assert (= s_parts_count (str.num_splits s "-")))
(assert (>= s_parts_count 3))
(declare-const s_head String)
(declare-const s_tail1 String)
(assert (= s_head (str.split_at s "-" 0)))
(assert (= s_tail1 (str.split_rest s "-" 1)))
; Further split s_tail1 by delimiter ":"
(declare-const s_subparts_count Int)
(assert (= s_subparts_count (str.num_splits s_tail1 ":")))
(assert (>= s_subparts_count 2))
(declare-const s_mid String)
(declare-const s_tail2 String)
(assert (= s_mid (str.split_at s_tail1 ":" 0)))
(assert (= s_tail2 (str.split_rest s_tail1 ":" 1)))
; Cross-dependency: the second part of s split by "-" must equal the first part of p split by ":"
(declare-const p_first String)
(assert (= p_first (str.split_at p ":" 0)))
(assert (= s_mid p_first))
; ; Advanced constraint: s_head is a prefix of p, and s_tail2 is a suffix of p
(assert (str.prefixof s_head p))
(assert (str.suffixof s_tail2 p))
; ; Split p by ":" and check relationships among segments
(declare-const p_parts_count Int)
(assert (= p_parts_count (str.num_splits p ":")))
(assert (>= p_parts_count 3))
(declare-const p_second String)
(assert (= p_second (str.split_at p ":" 1)))
; Validation: s_mid and p_second are not equal, and s_tail2 is not contained in s_head
(assert (not (= s_mid p_second)))
(assert (not (str.contains s_head s_tail2)))
; Additional cross-dependency: The length of s_head plus s_tail2 equals the length of p_first plus p_second
(assert (= (+ (str.len s_head) (str.len s_tail2)) (+ (str.len p_first) (str.len p_second))))
; --- End LLM Generated Constraints ---

(check-sat)

(get-model)
